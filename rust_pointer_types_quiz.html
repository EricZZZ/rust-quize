<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust 指针类型快问快答</title>
    <link rel="stylesheet" href="quiz-styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🦀 Rust 指针类型快问快答</h1>
            <p>测试你对Rust指针类型的理解程度</p>
        </div>

        <div class="quiz-info">
            <div class="info-item">
                <div class="number">10</div>
                <div class="label">题目数量</div>
            </div>
            <div class="info-item">
                <div class="number">15</div>
                <div class="label">预计时间(分钟)</div>
            </div>
            <div class="info-item">
                <div class="number">⭐⭐⭐</div>
                <div class="label">难度等级</div>
            </div>
        </div>

        <div class="content">
            <!-- 题目1 -->
            <div class="question" data-question="1">
                <div class="question-number">第1题 (判断题)</div>
                <div class="question-text">
                    在Rust中，引用(&T)和原始指针(*const T, *mut T)都是安全的。
                </div>
                <div class="options">
                    <div class="option" data-answer="false">正确</div>
                    <div class="option" data-answer="true">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：错误</strong></p>
                    <p>引用(&T)是安全的，由借用检查器保证内存安全。</p>
                    <p>原始指针(*const T, *mut T)是不安全的，解引用时需要使用unsafe块。</p>
                    <p>原始指针可能指向无效内存，不受借用检查器约束。</p>
                </div>
            </div>

            <!-- 题目2 -->
            <div class="question" data-question="2">
                <div class="question-number">第2题 (选择题)</div>
                <div class="question-text">
                    下列哪个是Rust中的智能指针类型？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">&amp;T</div>
                    <div class="option" data-answer="true">Box&lt;T&gt;</div>
                    <div class="option" data-answer="false">*const T</div>
                    <div class="option" data-answer="false">*mut T</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：Box&lt;T&gt;</strong></p>
                    <p>Box&lt;T&gt;是Rust中最基本的智能指针，用于在堆上分配内存。</p>
                    <p>&amp;T是引用，*const T和*mut T是原始指针，都不是智能指针。</p>
                    <p>其他智能指针还包括Rc&lt;T&gt;、Arc&lt;T&gt;、RefCell&lt;T&gt;等。</p>
                </div>
            </div>

            <!-- 题目3 -->
            <div class="question" data-question="3">
                <div class="question-number">第3题 (选择题)</div>
                <div class="question-text">
                    Rc&lt;T&gt;和Arc&lt;T&gt;的主要区别是什么？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">Rc&lt;T&gt;用于堆分配，Arc&lt;T&gt;用于栈分配</div>
                    <div class="option" data-answer="true">Rc&lt;T&gt;是单线程的，Arc&lt;T&gt;是多线程安全的</div>
                    <div class="option" data-answer="false">Rc&lt;T&gt;可变，Arc&lt;T&gt;不可变</div>
                    <div class="option" data-answer="false">没有区别，只是名字不同</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：Rc&lt;T&gt;是单线程的，Arc&lt;T&gt;是多线程安全的</strong></p>
                    <p>Rc&lt;T&gt;(Reference Counted)只能在单线程中使用，引用计数操作不是原子的。</p>
                    <p>Arc&lt;T&gt;(Atomically Reference Counted)使用原子操作，可以在多线程间安全共享。</p>
                    <p>两者都用于共享所有权，但Arc&lt;T&gt;有额外的线程安全开销。</p>
                </div>
            </div>

            <!-- 题目4 -->
            <div class="question" data-question="4">
                <div class="question-number">第4题 (判断题)</div>
                <div class="question-text">
                    RefCell&lt;T&gt;允许在运行时进行可变借用检查，可以绕过编译时的借用规则。
                </div>
                <div class="options">
                    <div class="option" data-answer="true">正确</div>
                    <div class="option" data-answer="false">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：正确</strong></p>
                    <p>RefCell&lt;T&gt;提供内部可变性，将借用检查从编译时推迟到运行时。</p>
                    <p>如果违反借用规则（如同时存在多个可变借用），程序会在运行时panic。</p>
                    <p>这允许在某些编译器无法验证安全性的情况下实现可变性。</p>
                </div>
            </div>

            <!-- 题目5 -->
            <div class="question" data-question="5">
                <div class="question-number">第5题 (选择题)</div>
                <div class="question-text">
                    以下代码的输出是什么？
                    <div class="code-block">let x = 42;
let ptr = &amp;x as *const i32;
println!("{:p}", ptr);</div>
                </div>
                <div class="options">
                    <div class="option" data-answer="false">42</div>
                    <div class="option" data-answer="true">内存地址</div>
                    <div class="option" data-answer="false">编译错误</div>
                    <div class="option" data-answer="false">运行时panic</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：内存地址</strong></p>
                    <p>{:p}格式化符用于打印指针的内存地址。</p>
                    <p>&amp;x as *const i32将引用转换为原始指针。</p>
                    <p>输出类似于"0x7fff5fbff6ac"的十六进制地址。</p>
                </div>
            </div>

            <!-- 题目6 -->
            <div class="question" data-question="6">
                <div class="question-number">第6题 (判断题)</div>
                <div class="question-text">
                    Weak&lt;T&gt;是Arc&lt;T&gt;的弱引用版本，不会增加引用计数，可以用来打破循环引用。
                </div>
                <div class="options">
                    <div class="option" data-answer="true">正确</div>
                    <div class="option" data-answer="false">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：正确</strong></p>
                    <p>Weak&lt;T&gt;是Arc&lt;T&gt;的弱引用，不会阻止值被释放。</p>
                    <p>当所有强引用(Arc)被释放后，即使还有弱引用存在，值也会被释放。</p>
                    <p>这是解决循环引用问题的重要工具，避免内存泄漏。</p>
                </div>
            </div>

            <!-- 题目7 -->
            <div class="question" data-question="7">
                <div class="question-number">第7题 (选择题)</div>
                <div class="question-text">
                    在unsafe块中解引用原始指针时，需要程序员保证什么？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">指针指向的类型正确</div>
                    <div class="option" data-answer="false">指针不为空且指向有效内存</div>
                    <div class="option" data-answer="false">内存对齐正确</div>
                    <div class="option" data-answer="true">以上所有</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：以上所有</strong></p>
                    <p>解引用原始指针时，程序员必须保证：</p>
                    <p>1. 指针不为空且指向有效的、已分配的内存</p>
                    <p>2. 指针指向的类型与声明的类型匹配</p>
                    <p>3. 内存对齐符合类型要求</p>
                    <p>4. 在指针生命周期内，内存不会被释放或重新分配</p>
                </div>
            </div>

            <!-- 题目8 -->
            <div class="question" data-question="8">
                <div class="question-number">第8题 (简答题)</div>
                <div class="question-text">
                    什么是"悬垂指针"(dangling pointer)？请简要说明。
                </div>
                <input type="text" class="text-input" placeholder="请输入答案" data-answer="指向已被释放内存的指针">
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：指向已被释放内存的指针</strong></p>
                    <p>悬垂指针是指向已经被释放或无效内存位置的指针。</p>
                    <p>在Rust中，借用检查器防止创建悬垂引用，但原始指针仍可能悬垂。</p>
                    <p>使用悬垂指针会导致未定义行为，可能造成程序崩溃或数据损坏。</p>
                </div>
            </div>

            <!-- 题目9 -->
            <div class="question" data-question="9">
                <div class="question-number">第9题 (选择题)</div>
                <div class="question-text">
                    以下哪种情况下应该使用Box&lt;T&gt;？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">需要多个所有者时</div>
                    <div class="option" data-answer="true">数据太大不适合放在栈上时</div>
                    <div class="option" data-answer="false">需要线程间共享时</div>
                    <div class="option" data-answer="false">需要内部可变性时</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：数据太大不适合放在栈上时</strong></p>
                    <p>Box&lt;T&gt;主要用于：</p>
                    <p>1. 将大型数据移到堆上，避免栈溢出</p>
                    <p>2. 创建递归数据结构（如链表、树）</p>
                    <p>3. 当编译时不知道类型大小时</p>
                    <p>多个所有者用Rc&lt;T&gt;，线程共享用Arc&lt;T&gt;，内部可变性用RefCell&lt;T&gt;。</p>
                </div>
            </div>

            <!-- 题目10 -->
            <div class="question" data-question="10">
                <div class="question-number">第10题 (简答题)</div>
                <div class="question-text">
                    Cell&lt;T&gt;和RefCell&lt;T&gt;的主要区别是什么？
                </div>
                <input type="text" class="text-input" placeholder="请输入答案" data-answer="Cell只能Copy类型，RefCell可以借用">
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：Cell&lt;T&gt;只适用于Copy类型，RefCell&lt;T&gt;可以借用任何类型</strong></p>
                    <p>Cell&lt;T&gt;：</p>
                    <p>- 只能用于实现Copy trait的类型</p>
                    <p>- 通过get()和set()方法操作，总是移动或复制值</p>
                    <p>- 零运行时开销，无借用检查</p>
                    <p>RefCell&lt;T&gt;：</p>
                    <p>- 可用于任何类型</p>
                    <p>- 通过borrow()和borrow_mut()方法借用</p>
                    <p>- 有运行时借用检查开销</p>
                </div>
            </div>

            <div class="text-center">
                <button class="btn" id="submitBtn" onclick="submitQuiz()">提交答案</button>
                <button class="btn" id="showAnswersBtn" onclick="showAllAnswers()" style="display: none;">查看所有解析</button>
                <button class="btn" id="restartBtn" onclick="restartQuiz()" style="display: none;">重新开始</button>
            </div>

            <div class="final-results" id="finalResults">
                <div class="result-icon" id="resultIcon">🎉</div>
                <div class="result-text" id="resultText">恭喜完成测验！</div>
                <div class="result-score" id="finalScore">10/10</div>
                <div id="resultMessage">你对Rust指针类型的掌握非常出色！</div>
            </div>
        </div>
    </div>

    <script>
        let userAnswers = {};
        let totalQuestions = 10;
        let quizSubmitted = false;

        // 处理选择题选项点击
        document.querySelectorAll('.option').forEach(option => {
            option.addEventListener('click', function() {
                if (quizSubmitted) return;
                
                const question = this.closest('.question');
                const questionNum = question.dataset.question;
                
                // 清除同一题目的其他选项
                question.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                
                // 选中当前选项
                this.classList.add('selected');
                
                // 记录答案
                userAnswers[questionNum] = {
                    type: 'option',
                    answer: this.dataset.answer === 'true',
                    element: this
                };
            });
        });

        // 处理简答题输入
        document.querySelectorAll('.text-input').forEach(input => {
            input.addEventListener('input', function() {
                if (quizSubmitted) return;
                
                const question = this.closest('.question');
                const questionNum = question.dataset.question;
                
                userAnswers[questionNum] = {
                    type: 'text',
                    answer: this.value.trim(),
                    correctAnswer: this.dataset.answer,
                    element: this
                };
            });
        });

        function submitQuiz() {
            if (Object.keys(userAnswers).length < totalQuestions) {
                alert('请完成所有题目后再提交！');
                return;
            }
            
            quizSubmitted = true;
            let correctCount = 0;
            
            // 检查答案并显示结果
            for (let questionNum in userAnswers) {
                const userAnswer = userAnswers[questionNum];
                const question = document.querySelector(`[data-question="${questionNum}"]`);
                const explanation = question.querySelector('.explanation');
                
                if (userAnswer.type === 'option') {
                    // 处理选择题
                    const isCorrect = userAnswer.answer;
                    if (isCorrect) {
                        correctCount++;
                        userAnswer.element.classList.add('correct');
                    } else {
                        userAnswer.element.classList.add('incorrect');
                        // 显示正确答案
                        question.querySelectorAll('.option').forEach(opt => {
                            if (opt.dataset.answer === 'true') {
                                opt.classList.add('correct');
                            }
                        });
                    }
                } else if (userAnswer.type === 'text') {
                    // 处理简答题（简单的关键词匹配）
                    const userText = userAnswer.answer.toLowerCase();
                    const correctText = userAnswer.correctAnswer.toLowerCase();
                    
                    if (userText.includes('copy') && userText.includes('借用') || 
                        userText.includes('cell') && userText.includes('refcell') ||
                        userText.includes('指向') && userText.includes('释放') ||
                        userText.includes('悬垂') || userText.includes('dangling')) {
                        correctCount++;
                        userAnswer.element.style.borderColor = '#27ae60';
                        userAnswer.element.style.backgroundColor = '#d5f4e6';
                    } else {
                        userAnswer.element.style.borderColor = '#e74c3c';
                        userAnswer.element.style.backgroundColor = '#fdf2f2';
                    }
                }
                
                explanation.style.display = 'block';
            }
            
            // 显示最终结果
            showFinalResults(correctCount);
            
            // 更新按钮状态
            document.getElementById('submitBtn').style.display = 'none';
            document.getElementById('showAnswersBtn').style.display = 'inline-block';
            document.getElementById('restartBtn').style.display = 'inline-block';
        }

        function showFinalResults(score) {
            const finalResults = document.getElementById('finalResults');
            const resultIcon = document.getElementById('resultIcon');
            const resultText = document.getElementById('resultText');
            const finalScore = document.getElementById('finalScore');
            const resultMessage = document.getElementById('resultMessage');
            
            finalScore.textContent = `${score}/${totalQuestions}`;
            
            if (score === totalQuestions) {
                resultIcon.textContent = '🏆';
                resultText.textContent = '完美！';
                resultMessage.textContent = '你对Rust指针类型的掌握非常出色！';
            } else if (score >= totalQuestions * 0.8) {
                resultIcon.textContent = '🎉';
                resultText.textContent = '很棒！';
                resultMessage.textContent = '你对Rust指针类型有很好的理解！';
            } else if (score >= totalQuestions * 0.6) {
                resultIcon.textContent = '👍';
                resultText.textContent = '不错！';
                resultMessage.textContent = '继续学习，你会掌握得更好！';
            } else {
                resultIcon.textContent = '📚';
                resultText.textContent = '继续努力！';
                resultMessage.textContent = '建议复习Rust指针类型的相关概念。';
            }
            
            finalResults.style.display = 'block';
            finalResults.scrollIntoView({ behavior: 'smooth' });
        }

        function showAllAnswers() {
            document.querySelectorAll('.explanation').forEach(explanation => {
                explanation.style.display = 'block';
            });
        }

        function restartQuiz() {
            // 重置所有状态
            userAnswers = {};
            quizSubmitted = false;
            
            // 清除选项状态
            document.querySelectorAll('.option').forEach(option => {
                option.classList.remove('selected', 'correct', 'incorrect');
            });
            
            // 清除输入框
            document.querySelectorAll('.text-input').forEach(input => {
                input.value = '';
                input.style.borderColor = '#e0e0e0';
                input.style.backgroundColor = 'white';
            });
            
            // 隐藏解析
            document.querySelectorAll('.explanation').forEach(explanation => {
                explanation.style.display = 'none';
            });
            
            // 隐藏结果
            document.getElementById('finalResults').style.display = 'none';
            
            // 重置按钮状态
            document.getElementById('submitBtn').style.display = 'inline-block';
            document.getElementById('showAnswersBtn').style.display = 'none';
            document.getElementById('restartBtn').style.display = 'none';
            
            // 滚动到顶部
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    </script>
</body>
</html>