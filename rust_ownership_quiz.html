<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust 所有权与移动 - 快问快答</title>
    <link rel="stylesheet" href="quiz-styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🦀 Rust 所有权与移动 - 快问快答</h1>
            <p>测试你对 Rust 所有权系统的理解</p>
        </div>

        <div class="quiz-info">
            <div class="info-item">
                <div class="number">10</div>
                <div class="label">题目数量</div>
            </div>
            <div class="info-item">
                <div class="number">20</div>
                <div class="label">预计时间(分钟)</div>
            </div>
            <div class="info-item">
                <div class="number">⭐⭐⭐⭐</div>
                <div class="label">难度等级</div>
            </div>
        </div>

        <div class="content">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <!-- 题目1 -->
            <div class="question" data-question="1">
                <div class="question-number">第1题 (判断题)</div>
                <div class="question-text">
                    在 Rust 中，当一个值被移动后，原来的变量就不能再使用了。
                </div>
                <div class="options">
                    <div class="option" data-answer="true">正确</div>
                    <div class="option" data-answer="false">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：正确</strong></p>
                    <p>当一个值被移动（move）后，原来的变量失去了对该值的所有权，编译器会阻止对原变量的进一步使用，这是 Rust 防止悬垂指针和双重释放的重要机制。</p>
                </div>
            </div>

            <!-- 题目2 -->
            <div class="question" data-question="2">
                <div class="question-number">第2题 (选择题)</div>
                <div class="question-text">
                    以下哪种类型实现了 Copy trait，因此赋值时不会发生移动？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">String</div>
                    <div class="option" data-answer="false">Vec&lt;i32&gt;</div>
                    <div class="option" data-answer="true">i32</div>
                    <div class="option" data-answer="false">Box&lt;i32&gt;</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：i32</strong></p>
                    <p>i32 是基本数据类型，实现了 Copy trait，赋值时会进行复制而不是移动。String、Vec&lt;i32&gt; 和 Box&lt;i32&gt; 都没有实现 Copy trait，赋值时会发生移动。</p>
                </div>
            </div>

            <!-- 题目3 -->
            <div class="question" data-question="3">
                <div class="question-number">第3题 (判断题)</div>
                <div class="question-text">
                    借用（borrowing）允许我们在不获取所有权的情况下使用值。
                </div>
                <div class="options">
                    <div class="option" data-answer="true">正确</div>
                    <div class="option" data-answer="false">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：正确</strong></p>
                    <p>借用（&T 或 &mut T）允许我们创建对值的引用，在不转移所有权的情况下访问和使用值。这是 Rust 所有权系统的核心特性之一。</p>
                </div>
            </div>

            <!-- 题目4 -->
            <div class="question" data-question="4">
                <div class="question-number">第4题 (选择题)</div>
                <div class="question-text">
                    在同一作用域中，对于同一个值，以下哪种借用组合是被允许的？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">多个可变借用</div>
                    <div class="option" data-answer="true">多个不可变借用</div>
                    <div class="option" data-answer="false">一个可变借用和一个不可变借用</div>
                    <div class="option" data-answer="false">以上都不允许</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：多个不可变借用</strong></p>
                    <p>Rust 的借用规则：在同一时间，要么有一个可变借用，要么有任意数量的不可变借用，但不能同时存在。多个不可变借用是安全的，因为它们不会修改数据。</p>
                </div>
            </div>

            <!-- 题目5 -->
            <div class="question" data-question="5">
                <div class="question-number">第5题 (简答题)</div>
                <div class="question-text">
                    什么是 Rust 中的"悬垂引用"（dangling reference）？Rust 如何防止悬垂引用？
                </div>
                <input type="text" class="text-input" placeholder="请输入你的答案" data-answer="悬垂引用,生命周期">
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>参考答案：</strong></p>
                    <p>悬垂引用是指向已被释放内存的引用。Rust 通过生命周期（lifetime）系统防止悬垂引用：编译器确保引用的生命周期不会超过被引用值的生命周期，如果检测到可能的悬垂引用，编译器会报错。</p>
                </div>
            </div>

            <!-- 题目6 -->
            <div class="question" data-question="6">
                <div class="question-number">第6题 (选择题)</div>
                <div class="question-text">
                    以下代码中，哪一行会导致编译错误？
                </div>
                <div class="code-block">let s1 = String::from("hello");  // 第1行
let s2 = s1;                     // 第2行
println!("{}", s1);              // 第3行
println!("{}", s2);              // 第4行</div>
                <div class="options">
                    <div class="option" data-answer="false">第1行</div>
                    <div class="option" data-answer="false">第2行</div>
                    <div class="option" data-answer="true">第3行</div>
                    <div class="option" data-answer="false">第4行</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：第3行</strong></p>
                    <p>第2行将 s1 的所有权移动给了 s2，之后 s1 就不能再使用了。第3行尝试使用已被移动的 s1，会导致编译错误："borrow of moved value"。</p>
                </div>
            </div>

            <!-- 题目7 -->
            <div class="question" data-question="7">
                <div class="question-number">第7题 (判断题)</div>
                <div class="question-text">
                    Clone trait 允许我们显式地复制一个值，避免移动语义。
                </div>
                <div class="options">
                    <div class="option" data-answer="true">正确</div>
                    <div class="option" data-answer="false">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：正确</strong></p>
                    <p>Clone trait 提供了 clone() 方法，允许我们显式地创建值的深拷贝。当我们调用 clone() 时，原值保持有效，新值获得独立的所有权，从而避免了移动语义。</p>
                </div>
            </div>

            <!-- 题目8 -->
            <div class="question" data-question="8">
                <div class="question-number">第8题 (选择题)</div>
                <div class="question-text">
                    在函数参数传递中，以下哪种方式不会转移所有权？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">按值传递 (fn func(s: String))</div>
                    <div class="option" data-answer="false">按引用传递 (fn func(s: &String))</div>
                    <div class="option" data-answer="false">按可变引用传递 (fn func(s: &mut String))</div>
                    <div class="option" data-answer="true">按引用传递和按可变引用传递都不会</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：按引用传递和按可变引用传递都不会</strong></p>
                    <p>按值传递会转移所有权，而按引用传递（&T）和按可变引用传递（&mut T）都只是借用，不会转移所有权，调用者仍然拥有原值。</p>
                </div>
            </div>

            <!-- 题目9 -->
            <div class="question" data-question="9">
                <div class="question-number">第9题 (简答题)</div>
                <div class="question-text">
                    解释 Rust 中 Copy 和 Clone 的区别。
                </div>
                <input type="text" class="text-input" placeholder="请输入你的答案" data-answer="copy,clone">
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>参考答案：</strong></p>
                    <p>Copy 是隐式的、廉价的位复制，只能用于简单类型（如基本数据类型），赋值时自动复制；Clone 是显式的、可能昂贵的深拷贝，需要手动调用 clone() 方法，可以用于复杂类型。Copy 类型的赋值不会发生移动，而非 Copy 类型的赋值会发生移动（除非显式 clone）。</p>
                </div>
            </div>

            <!-- 题目10 -->
            <div class="question" data-question="10">
                <div class="question-number">第10题 (选择题)</div>
                <div class="question-text">
                    以下关于 Rust 所有权的描述，哪个是错误的？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">每个值在任意时刻都有且仅有一个所有者</div>
                    <div class="option" data-answer="false">当所有者离开作用域时，值会被自动释放</div>
                    <div class="option" data-answer="true">一个值可以同时有多个所有者</div>
                    <div class="option" data-answer="false">赋值和函数调用可能导致所有权转移</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：一个值可以同时有多个所有者</strong></p>
                    <p>这是错误的。Rust 所有权的核心规则之一就是每个值在任意时刻都有且仅有一个所有者。如果需要多个"所有者"，可以使用 Rc&lt;T&gt; 或 Arc&lt;T&gt; 等智能指针。</p>
                </div>
            </div>
        </div>

            <div class="text-center">
                <button class="btn" id="submitBtn" onclick="submitQuiz()">提交答案</button>
                <button class="btn" id="showAnswersBtn" onclick="showAllAnswers()" style="display: none;">查看所有解析</button>
                <button class="btn" id="restartBtn" onclick="restartQuiz()" style="display: none;">重新开始</button>
            </div>

            <div class="final-results" id="finalResults">
                <div class="result-icon" id="resultIcon">🎉</div>
                <div class="result-text" id="resultText">恭喜完成测验！</div>
                <div class="result-score" id="finalScore">10/10</div>
                <div id="resultMessage">你对Rust所有权系统的掌握非常出色！</div>
            </div>
        </div>
    </div>
    </div>

    <script>
        let userAnswers = {};
        let totalQuestions = 10;
        let quizSubmitted = false;

        // 处理选择题选项点击
        document.querySelectorAll('.option').forEach(option => {
            option.addEventListener('click', function() {
                if (quizSubmitted) return;
                
                const question = this.closest('.question');
                const questionNum = question.dataset.question;
                
                // 清除同一题目的其他选项
                question.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                
                // 选中当前选项
                this.classList.add('selected');
                
                // 记录答案
                userAnswers[questionNum] = {
                    type: 'option',
                    answer: this.dataset.answer === 'true',
                    element: this
                };
                
                updateProgress();
            });
        });

        // 处理简答题输入
        document.querySelectorAll('.text-input').forEach(input => {
            input.addEventListener('input', function() {
                if (quizSubmitted) return;
                
                const question = this.closest('.question');
                const questionNum = question.dataset.question;
                
                userAnswers[questionNum] = {
                    type: 'text',
                    answer: this.value.trim(),
                    element: this
                };
                
                updateProgress();
            });
        });

        function updateProgress() {
            const answered = Object.keys(userAnswers).length;
            const percentage = (answered / totalQuestions) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            
            // 启用/禁用提交按钮
            document.getElementById('submitBtn').disabled = answered < totalQuestions;
        }

        function submitQuiz() {
            if (Object.keys(userAnswers).length < totalQuestions) {
                alert('请完成所有题目后再提交！');
                return;
            }
            
            quizSubmitted = true;
            let correctCount = 0;
            
            // 检查答案并显示结果
            for (let questionNum in userAnswers) {
                const userAnswer = userAnswers[questionNum];
                const question = document.querySelector(`[data-question="${questionNum}"]`);
                const explanation = question.querySelector('.explanation');
                
                if (userAnswer.type === 'option') {
                    // 处理选择题
                    const isCorrect = userAnswer.answer;
                    if (isCorrect) {
                        correctCount++;
                        userAnswer.element.classList.add('correct');
                    } else {
                        userAnswer.element.classList.add('incorrect');
                        // 显示正确答案
                        question.querySelectorAll('.option').forEach(opt => {
                            if (opt.dataset.answer === 'true') {
                                opt.classList.add('correct');
                            }
                        });
                    }
                } else if (userAnswer.type === 'text') {
                    // 处理简答题（关键词匹配）
                    const userText = userAnswer.answer.toLowerCase();
                    
                    let isCorrect = false;
                    if (questionNum === '5') {
                        // 第5题：检查是否包含悬垂引用和生命周期相关概念
                        isCorrect = userText.includes('悬垂引用') || userText.includes('dangling') || 
                                   userText.includes('生命周期') || userText.includes('lifetime') ||
                                   userText.includes('引用') || userText.includes('reference');
                    } else if (questionNum === '9') {
                        // 第9题：检查是否包含Copy和Clone相关概念
                        isCorrect = (userText.includes('copy') || userText.includes('复制')) && 
                                   (userText.includes('clone') || userText.includes('克隆'));
                    }
                    
                    if (isCorrect) {
                        correctCount++;
                        userAnswer.element.style.borderColor = '#27ae60';
                        userAnswer.element.style.backgroundColor = '#d5f4e6';
                    } else {
                        userAnswer.element.style.borderColor = '#e74c3c';
                        userAnswer.element.style.backgroundColor = '#fadbd8';
                    }
                }
                
                // 显示解析
                if (explanation) {
                    explanation.style.display = 'block';
                }
            }
            
            showFinalResults(correctCount);
        }

        function showFinalResults(correctCount) {
            const percentage = Math.round((correctCount / totalQuestions) * 100);
            
            // 更新结果显示
            document.getElementById('finalScore').textContent = `${correctCount}/${totalQuestions}`;
            
            let resultIcon = '🎉';
            let resultText = '恭喜完成测验！';
            let resultMessage = '';
            
            if (percentage >= 90) {
                resultIcon = '🎉';
                resultText = '优秀！';
                resultMessage = '你对Rust所有权系统的掌握非常出色！';
            } else if (percentage >= 70) {
                resultIcon = '👍';
                resultText = '良好！';
                resultMessage = '你已经掌握了Rust所有权的基本概念！';
            } else if (percentage >= 60) {
                resultIcon = '📚';
                resultText = '及格！';
                resultMessage = '建议继续学习Rust所有权相关知识。';
            } else {
                resultIcon = '💪';
                resultText = '需要加强！';
                resultMessage = '建议重新学习Rust所有权系统的基础知识。';
            }
            
            document.getElementById('resultIcon').textContent = resultIcon;
            document.getElementById('resultText').textContent = resultText;
            document.getElementById('resultMessage').textContent = resultMessage;
            
            document.getElementById('finalResults').style.display = 'block';
            
            // 隐藏提交按钮，显示重新开始按钮
            document.getElementById('submitBtn').style.display = 'none';
            document.getElementById('restartBtn').style.display = 'inline-block';
            
            // 滚动到结果区域
            document.getElementById('finalResults').scrollIntoView({ behavior: 'smooth' });
        }

        function showAllAnswers() {
            document.querySelectorAll('.explanation').forEach(explanation => {
                explanation.style.display = 'block';
            });
            
            showAnswersBtn.style.display = 'none';
        }

        function restartQuiz() {
            // 重置所有变量
            userAnswers = {};
            quizSubmitted = false;
            
            // 清除所有选择
            document.querySelectorAll('.option').forEach(option => {
                option.classList.remove('selected', 'correct', 'incorrect');
                option.style.backgroundColor = '';
                option.style.borderColor = '';
            });
            
            // 清除所有文本输入
            document.querySelectorAll('textarea').forEach(textarea => {
                textarea.value = '';
                textarea.style.borderColor = '';
                textarea.style.backgroundColor = '';
            });
            
            // 隐藏所有解释
            document.querySelectorAll('.explanation').forEach(explanation => {
                explanation.style.display = 'none';
            });
            
            // 重置按钮和结果显示
            document.getElementById('finalResults').style.display = 'none';
            document.getElementById('submitBtn').style.display = 'inline-block';
            document.getElementById('submitBtn').disabled = true;
            document.getElementById('restartBtn').style.display = 'none';
            
            // 滚动到顶部
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            // 重新初始化进度
            updateProgress();
        }

        // 按钮事件通过onclick属性绑定
        
        // 初始化
        updateProgress();
    </script>
</body>
</html>