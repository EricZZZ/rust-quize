<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust 数组、向量和切片快问快答</title>
    <link rel="stylesheet" href="quiz-styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🦀 Rust 数组、向量和切片快问快答</h1>
            <p>测试你对Rust集合类型的理解程度</p>
        </div>

        <div class="quiz-info">
            <div class="info-item">
                <div class="number">10</div>
                <div class="label">题目数量</div>
            </div>
            <div class="info-item">
                <div class="number">18</div>
                <div class="label">预计时间(分钟)</div>
            </div>
            <div class="info-item">
                <div class="number">⭐⭐⭐</div>
                <div class="label">难度等级</div>
            </div>
        </div>

        <div class="content">
            <!-- 题目1 -->
            <div class="question" data-question="1">
                <div class="question-number">第1题 (判断题)</div>
                <div class="question-text">
                    在Rust中，数组的长度是固定的，而向量(Vec)的长度是可变的。
                </div>
                <div class="options">
                    <div class="option" data-answer="true">正确</div>
                    <div class="option" data-answer="false">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：正确</strong></p>
                    <p>数组([T; N])的长度在编译时确定，是类型的一部分，不能改变。</p>
                    <p>向量(Vec&lt;T&gt;)是动态数组，可以在运行时增加或删除元素。</p>
                    <p>例如：[i32; 5]是固定长度的数组，Vec&lt;i32&gt;是可变长度的向量。</p>
                </div>
            </div>

            <!-- 题目2 -->
            <div class="question" data-question="2">
                <div class="question-number">第2题 (选择题)</div>
                <div class="question-text">
                    下列哪种方式可以创建一个包含5个元素，每个元素都是0的数组？
                </div>
                <div class="options">
                    <div class="option" data-answer="true">[0; 5]</div>
                    <div class="option" data-answer="false">[0, 0, 0, 0, 0]</div>
                    <div class="option" data-answer="false">vec![0; 5]</div>
                    <div class="option" data-answer="false">以上都可以</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：[0; 5]</strong></p>
                    <p>[0; 5]是创建数组的语法，表示5个元素都是0的数组。</p>
                    <p>[0, 0, 0, 0, 0]也能创建相同的数组，但比较冗长。</p>
                    <p>vec![0; 5]创建的是向量，不是数组。</p>
                    <p>虽然后两种方式在某些情况下可行，但题目问的是最直接的方式。</p>
                </div>
            </div>

            <!-- 题目3 -->
            <div class="question" data-question="3">
                <div class="question-number">第3题 (选择题)</div>
                <div class="question-text">
                    切片(&[T])和数组([T; N])的主要区别是什么？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">切片存储在堆上，数组存储在栈上</div>
                    <div class="option" data-answer="true">切片长度在运行时确定，数组长度在编译时确定</div>
                    <div class="option" data-answer="false">切片可变，数组不可变</div>
                    <div class="option" data-answer="false">切片只能包含引用，数组包含实际值</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：切片长度在运行时确定，数组长度在编译时确定</strong></p>
                    <p>切片(&[T])是对连续内存区域的引用，长度在运行时确定。</p>
                    <p>数组([T; N])的长度N是编译时常量，是类型的一部分。</p>
                    <p>切片本身是一个胖指针，包含指向数据的指针和长度信息。</p>
                    <p>数组和切片都可以是可变的或不可变的，取决于声明方式。</p>
                </div>
            </div>

            <!-- 题目4 -->
            <div class="question" data-question="4">
                <div class="question-number">第4题 (判断题)</div>
                <div class="question-text">
                    Vec&lt;T&gt;在内存中总是连续存储的，就像数组一样。
                </div>
                <div class="options">
                    <div class="option" data-answer="true">正确</div>
                    <div class="option" data-answer="false">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：正确</strong></p>
                    <p>Vec&lt;T&gt;确实在内存中连续存储元素，这保证了良好的缓存局部性。</p>
                    <p>Vec&lt;T&gt;内部使用一个指向堆内存的指针、容量和长度来管理数据。</p>
                    <p>这种连续存储使得Vec&lt;T&gt;可以高效地转换为切片(&[T])。</p>
                    <p>当容量不足时，Vec会重新分配更大的连续内存块。</p>
                </div>
            </div>

            <!-- 题目5 -->
            <div class="question" data-question="5">
                <div class="question-number">第5题 (选择题)</div>
                <div class="question-text">
                    以下代码的输出是什么？
                    <div class="code-block">let arr = [1, 2, 3, 4, 5];
let slice = &arr[1..4];
println!("{}", slice.len());</div>
                </div>
                <div class="options">
                    <div class="option" data-answer="false">2</div>
                    <div class="option" data-answer="true">3</div>
                    <div class="option" data-answer="false">4</div>
                    <div class="option" data-answer="false">5</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：3</strong></p>
                    <p>&arr[1..4]创建一个从索引1到3（不包括4）的切片。</p>
                    <p>包含的元素是：arr[1] = 2, arr[2] = 3, arr[3] = 4。</p>
                    <p>所以切片长度是3。</p>
                    <p>范围语法[start..end)是左闭右开区间。</p>
                </div>
            </div>

            <!-- 题目6 -->
            <div class="question" data-question="6">
                <div class="question-number">第6题 (选择题)</div>
                <div class="question-text">
                    下列哪个方法可以向Vec&lt;T&gt;的末尾添加元素？
                </div>
                <div class="options">
                    <div class="option" data-answer="true">push()</div>
                    <div class="option" data-answer="false">append()</div>
                    <div class="option" data-answer="false">insert()</div>
                    <div class="option" data-answer="false">add()</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：push()</strong></p>
                    <p>push()方法将元素添加到向量的末尾。</p>
                    <p>append()方法将另一个向量的所有元素移动到当前向量末尾。</p>
                    <p>insert()方法在指定位置插入元素。</p>
                    <p>Rust中没有add()方法用于向量操作。</p>
                </div>
            </div>

            <!-- 题目7 -->
            <div class="question" data-question="7">
                <div class="question-number">第7题 (判断题)</div>
                <div class="question-text">
                    可以直接比较两个不同长度的数组类型，例如[i32; 3]和[i32; 5]。
                </div>
                <div class="options">
                    <div class="option" data-answer="false">正确</div>
                    <div class="option" data-answer="true">错误</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：错误</strong></p>
                    <p>[i32; 3]和[i32; 5]是不同的类型，不能直接比较。</p>
                    <p>数组的长度是类型的一部分，不同长度的数组是不同类型。</p>
                    <p>如果要比较内容，需要先转换为切片：&arr1[..] == &arr2[..]。</p>
                    <p>或者使用as_slice()方法转换后再比较。</p>
                </div>
            </div>

            <!-- 题目8 -->
            <div class="question" data-question="8">
                <div class="question-number">第8题 (简答题)</div>
                <div class="question-text">
                    Vec&lt;T&gt;的capacity()和len()方法有什么区别？
                </div>
                <input type="text" class="text-input" placeholder="请输入答案" data-answer="capacity是容量len是长度">
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：capacity()返回容量，len()返回长度</strong></p>
                    <p>len()返回向量中实际存储的元素数量。</p>
                    <p>capacity()返回向量在不重新分配内存的情况下可以存储的元素数量。</p>
                    <p>capacity >= len，当len达到capacity时，push新元素会触发内存重新分配。</p>
                    <p>可以使用with_capacity()或reserve()来预分配容量，避免频繁重新分配。</p>
                </div>
            </div>

            <!-- 题目9 -->
            <div class="question" data-question="9">
                <div class="question-number">第9题 (选择题)</div>
                <div class="question-text">
                    以下哪种切片语法是正确的？
                </div>
                <div class="options">
                    <div class="option" data-answer="false">&arr[..3]</div>
                    <div class="option" data-answer="false">&arr[2..]</div>
                    <div class="option" data-answer="false">&arr[1..4]</div>
                    <div class="option" data-answer="true">以上都正确</div>
                </div>
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：以上都正确</strong></p>
                    <p>&arr[..3] - 从开始到索引2（不包括3）</p>
                    <p>&arr[2..] - 从索引2到结尾</p>
                    <p>&arr[1..4] - 从索引1到索引3（不包括4）</p>
                    <p>还有&arr[..]表示整个数组的切片。</p>
                </div>
            </div>

            <!-- 题目10 -->
            <div class="question" data-question="10">
                <div class="question-number">第10题 (简答题)</div>
                <div class="question-text">
                    什么是"胖指针"(fat pointer)？在Rust的切片中如何体现？
                </div>
                <input type="text" class="text-input" placeholder="请输入答案" data-answer="包含指针和长度信息的指针">
                <div class="explanation">
                    <h4>答案解析：</h4>
                    <p><strong>答案：包含指针和长度信息的指针</strong></p>
                    <p>胖指针是包含额外元数据的指针，不只是内存地址。</p>
                    <p>切片(&[T])是胖指针，包含：</p>
                    <p>1. 指向数据起始位置的指针</p>
                    <p>2. 切片的长度信息</p>
                    <p>这使得切片可以安全地知道自己的边界，防止越界访问。</p>
                    <p>相比之下，普通指针(*const T)只包含内存地址。</p>
                </div>
            </div>

            <div class="text-center">
                <button class="btn" id="submitBtn" onclick="submitQuiz()">提交答案</button>
                <button class="btn" id="showAnswersBtn" onclick="showAllAnswers()" style="display: none;">查看所有解析</button>
                <button class="btn" id="restartBtn" onclick="restartQuiz()" style="display: none;">重新开始</button>
            </div>

            <div class="final-results" id="finalResults">
                <div class="result-icon" id="resultIcon">🎉</div>
                <div class="result-text" id="resultText">恭喜完成测验！</div>
                <div class="result-score" id="finalScore">10/10</div>
                <div id="resultMessage">你对Rust集合类型的掌握非常出色！</div>
            </div>
        </div>
    </div>

    <script>
        let userAnswers = {};
        let totalQuestions = 10;
        let quizSubmitted = false;

        // 处理选择题选项点击
        document.querySelectorAll('.option').forEach(option => {
            option.addEventListener('click', function() {
                if (quizSubmitted) return;
                
                const question = this.closest('.question');
                const questionNum = question.dataset.question;
                
                // 清除同一题目的其他选项
                question.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                
                // 选中当前选项
                this.classList.add('selected');
                
                // 记录答案
                userAnswers[questionNum] = {
                    type: 'option',
                    answer: this.dataset.answer === 'true',
                    element: this
                };
            });
        });

        // 处理简答题输入
        document.querySelectorAll('.text-input').forEach(input => {
            input.addEventListener('input', function() {
                if (quizSubmitted) return;
                
                const question = this.closest('.question');
                const questionNum = question.dataset.question;
                
                userAnswers[questionNum] = {
                    type: 'text',
                    answer: this.value.trim(),
                    correctAnswer: this.dataset.answer,
                    element: this
                };
            });
        });

        function submitQuiz() {
            if (Object.keys(userAnswers).length < totalQuestions) {
                alert('请完成所有题目后再提交！');
                return;
            }
            
            quizSubmitted = true;
            let correctCount = 0;
            
            // 检查答案并显示结果
            for (let questionNum in userAnswers) {
                const userAnswer = userAnswers[questionNum];
                const question = document.querySelector(`[data-question="${questionNum}"]`);
                const explanation = question.querySelector('.explanation');
                
                if (userAnswer.type === 'option') {
                    // 处理选择题
                    const isCorrect = userAnswer.answer;
                    if (isCorrect) {
                        correctCount++;
                        userAnswer.element.classList.add('correct');
                    } else {
                        userAnswer.element.classList.add('incorrect');
                        // 显示正确答案
                        question.querySelectorAll('.option').forEach(opt => {
                            if (opt.dataset.answer === 'true') {
                                opt.classList.add('correct');
                            }
                        });
                    }
                } else if (userAnswer.type === 'text') {
                    // 处理简答题（简单的关键词匹配）
                    const userText = userAnswer.answer.toLowerCase();
                    const correctText = userAnswer.correctAnswer.toLowerCase();
                    
                    if (userText.includes('capacity') && userText.includes('len') ||
                        userText.includes('容量') && userText.includes('长度') ||
                        userText.includes('指针') && userText.includes('长度') ||
                        userText.includes('pointer') && userText.includes('length') ||
                        userText.includes('胖指针') || userText.includes('fat pointer')) {
                        correctCount++;
                        userAnswer.element.style.borderColor = '#27ae60';
                        userAnswer.element.style.backgroundColor = '#d5f4e6';
                    } else {
                        userAnswer.element.style.borderColor = '#e74c3c';
                        userAnswer.element.style.backgroundColor = '#fdf2f2';
                    }
                }
                
                explanation.style.display = 'block';
            }
            
            // 显示最终结果
            showFinalResults(correctCount);
            
            // 更新按钮状态
            document.getElementById('submitBtn').style.display = 'none';
            document.getElementById('showAnswersBtn').style.display = 'inline-block';
            document.getElementById('restartBtn').style.display = 'inline-block';
        }

        function showFinalResults(score) {
            const finalResults = document.getElementById('finalResults');
            const resultIcon = document.getElementById('resultIcon');
            const resultText = document.getElementById('resultText');
            const finalScore = document.getElementById('finalScore');
            const resultMessage = document.getElementById('resultMessage');
            
            finalScore.textContent = `${score}/${totalQuestions}`;
            
            if (score === totalQuestions) {
                resultIcon.textContent = '🏆';
                resultText.textContent = '完美！';
                resultMessage.textContent = '你对Rust集合类型的掌握非常出色！';
            } else if (score >= totalQuestions * 0.8) {
                resultIcon.textContent = '🎉';
                resultText.textContent = '很棒！';
                resultMessage.textContent = '你对Rust集合类型有很好的理解！';
            } else if (score >= totalQuestions * 0.6) {
                resultIcon.textContent = '👍';
                resultText.textContent = '不错！';
                resultMessage.textContent = '继续学习，你会掌握得更好！';
            } else {
                resultIcon.textContent = '📚';
                resultText.textContent = '继续努力！';
                resultMessage.textContent = '建议复习Rust集合类型的相关概念。';
            }
            
            finalResults.style.display = 'block';
            finalResults.scrollIntoView({ behavior: 'smooth' });
        }

        function showAllAnswers() {
            document.querySelectorAll('.explanation').forEach(explanation => {
                explanation.style.display = 'block';
            });
        }

        function restartQuiz() {
            // 重置所有状态
            userAnswers = {};
            quizSubmitted = false;
            
            // 清除选项状态
            document.querySelectorAll('.option').forEach(option => {
                option.classList.remove('selected', 'correct', 'incorrect');
            });
            
            // 清除输入框
            document.querySelectorAll('.text-input').forEach(input => {
                input.value = '';
                input.style.borderColor = '#e0e0e0';
                input.style.backgroundColor = 'white';
            });
            
            // 隐藏解析
            document.querySelectorAll('.explanation').forEach(explanation => {
                explanation.style.display = 'none';
            });
            
            // 隐藏结果
            document.getElementById('finalResults').style.display = 'none';
            
            // 重置按钮状态
            document.getElementById('submitBtn').style.display = 'inline-block';
            document.getElementById('showAnswersBtn').style.display = 'none';
            document.getElementById('restartBtn').style.display = 'none';
            
            // 滚动到顶部
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    </script>
</body>
</html>